;Memory Tester for the Rockwell AIM-65
;Using the memory test routines from the OSI MEMORY TEST from OS65D 2.0 published in OSI Small System Journal Vol1 No.3, Sept 1977
;Runs from the $F000 page 4K ROM
;
;Usage:
;Assemble the test. Burn the binary to a 2532 EPROM, or to a 2732 EPROM if using a revision 4/5 AIM-65 jumpered to support it.
;Insert the ROM into ROM socket Z22 ($F000) and power on the machine. The ROM will perform the following tests:
; - Stack page quick write presence
; - Zero page quick write presence
; - RIOT single-pass memory test
; - Full system memory test
;
;Stack Page Quick Write Presence:
;This test ensures that the stack page in low RAM is present and functional enough to run the rest of the tests. If this
;  test fails, ensure that the low RAM ICs are installed and are good. The test operates in the following way:
;$00 is written to and then read back from addresses $100 to $1FF. If anything except for $00 is read back, the test fails
;  and a message is displayed. $FF is then written to the same range and checked. If anything except for $FF is read back,
;  the test fails with the same error.
;
;Zero Page Quick Write Presence:
;This test ensures that the zero page in low RAM is present and functional enough to run the rest of the tests. If this
;  test fails, and the stack page test passes, the low RAM ICs are at fault. The operation of this test is identical
;  to the stack page quick test, except that it operates in the range of $00-$FF as opposed to $100-$1FF.
;
;RIOT Single-Pass Memory Test:
;This test checks the RAM of the RIOT separately. The RIOT's RAM is present at a higher memory address that is isolated from
;  the main system memory, necessitating the use of this separate test. The RIOT's function is not needed for the main system
;  memory test, but it is needed for the AIM-65 monitor ROM set. The test operates identically to the main system memory test
;  (which is described in the next test description), with the exception that only the address range of $A400-$A47F is tested,
;  and only one pass is performed.
;
;Full System Memory Test:
;This test tests the entire main system memory with the exception of zero page and the stack page. Before the test is run, a 
;  memory sizing routine is called which automatically determines the top of memory for the following test to test up to. 
;  The test itself then starts. The test display is shown as:
;
;  0300-XXXX P=YY C=ZZ
;
; - 0300: The starting address of the test. Set to $0300 for the full test, as this is where main memory starts. For the RIOT
;           single-pass test, this is set to $A400. Each memory test cycle starts at this address.
; - XXXX: The ending address of the test. Set based on the autosizing routine. For the RIOT single-pass test, this is set to
;           $A47F. Each memory test cycle ends at this address before starting over for the next cycle.
; - P=YY: The pass counter. Each pass takes 256 cycles. After 256 cycles, the pass counter increments by 1. For the RIOT
;           single-pass test, only one pass is performed.
; - C=ZZ: The cycle counter. The cycle counter is incremented every time the memory test works its way from the starting
;           address to the ending address. The cycle count itself is used as part of the memory test to "seed" the
;           pattern used during that cycle. Each cycle will therefore test every single bit pattern in every byte.
;
;If an error is encountered during the memory test, it will be displayed in the following format:
;
;  ERROR@XXXX E=YY R=ZZ
;
;  - XXXX: The address where the error was encountered.
;  - E=YY: The byte that was expected to be read from the address.
;  - R=ZZ: The byte that was actually read from the address.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MEMBEG -- Starting Address for Memory Autosize
;
;This value can be set higher to preserve the contents of
;memory at lower addresses.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MEMBEG	=	$200		;Default to 0x0200, above stack

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;AIM-65 ASCII Display Equates
;
;The AIM-65's ASCII displays are interfaced through a PIA,
;rather than sitting directly on the 6502's system bus.
;
;Display PIA bit assignments:
;PA0 = A0	Digit select 0
;PA1 = A1	Digit select 1
;PA2 = *CE1	Display 0	111110XX
;PA3 = *CE2	Display 1	111101XX
;PA4 = *CE3	Dispaly 2	111011XX
;PA5 = *CE4	Display 3	110111XX
;PA6 = *CE5	Display 4	101111XX
;PA7 = *W	Write		Data is clocked into display on 
;				rising edge
;
;PB0-PB6 = D0-D6	Data
;PB7 = *CU		Cursor input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PIA	=	$AC00		;Display PIA base address
PIAORA	=	PIA+0		;Port A output register
PIADDA	=	PIA+0		;Port A data direction register
PIACRA	=	PIA+1		;Port A control register
PIAORB	=	PIA+2		;Port B output register
PIADDB	=	PIA+2		;Port B data direction register
PIACRB	=	PIA+3		;Port B control register
CHARMOD	=	#$80		;Character output mode OR mask
CURSMOD	=	#$7F		;Cursor output mode AND mask
DCEIDLE	=	#%11111100	;Display select bits idle state
DISPWR	=	#$7F		;Write to display AND mask
NDISPWR	=	#$80		;Disable display write OR mask

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Zero Page Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
USRCMD	=	$C4		;Command character entered by the user
PASCTR	=	$C5		;Pass Counter
MAXPAS	=	$C6		;Maximum number of passes
VAR1	=	$C7
VAR2	=	$C8
VAR3	=	$C9
MEMPTR	=	$CA
MEMPLO	=	MEMPTR
MEMPHI	=	MEMPTR+1
ENDPTR	=	$CC
ENDPLO	=	ENDPTR
ENDPHI	=	ENDPTR+1
TEMP	=	$CE

;Page sum macro
;Assumes that X is already 0
.macro	PGESUM	ADDR
.local	PSUMLP
PSUMLP:	CLC
	ADC	ADDR,X
	INX
	BNE	PSUMLP
.endmacro

;Page test macro
.macro	PGETST	ADDR
.local	PTSTW, PTSTR, TSTBAD, END
	LDX	#$00		;Pattern
	LDY	#$00		;Index
;Page test write loop.
PTSTW:	TXA
	STA	ADDR,Y
	INX
	INY
	BNE	PTSTW
	;X = starting pattern value
	;Y = 0
;Page test read loop
PTSTR:	TXA			;Transfer the pattern to A
	CMP	ADDR,Y		;Compare the pattern to what was written
	BNE	TSTBAD		;If different, return with error
	INX
	INY
	BNE	PTSTR
	;X = starting pattern value
	;Y = 0
	INX			;Increment X to the next starting pattern bitmap
	BNE	PTSTW		;Start the next cycle if pattern is not 0
	;Once the starting pattern returns to 0, the test is done
	CLC			;Return with carry clear, indicating a successful test
	BCC	END
TSTBAD:	SEC			;Return with carry set, indicating a failed test
END:
.endmacro

;Simple delay macro
.macro SDELAY
.local	DLOOP1, DLOOP2
	LDX	#$FF
DLOOP1:	LDY	#$FF

DLOOP2:	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DEY
	BNE	DLOOP2
	DEX
	BNE	DLOOP1
.endmacro

;Simple message printer macro
.macro	SPMSG ADDR
.local	MSPLUP
	LDX	#$00
MSPLUP:	LDA	ADDR,X
	ORA	#$80
	STA	PIAORB
	LDA	DISPCE,X
	STA	PIAORA
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	MSPLUP
.endmacro


;Checksum the ROM before tests
;Change $00 $FF tests to include $AA and $55. Make less address dependant
.segment "CODE"
START:	SEI
	LDX	#$FF
	TXS

	;Select the output registers of ports A and B
	LDA	#04
	STA	PIACRA
	STA	PIACRB

	;Reset the display select bits to their resting state
	LDA	#%11111100
	STA	PIAORA
	;Reset the data bits to their resting state
	LDA	#$80
	STA	PIAORB

	LDA	#00
	STA	PIACRA
	STA	PIACRB
	LDA	#$FF
	STA	PIADDA
	STA	PIADDB

	LDA	#04
	STA	PIACRA
	STA	PIACRB

	;Clear all of the cursor bits
	LDX	#$00		
CURCLP:	LDA	#$00		;D0 = 0, ~CU = 0
	STA	PIAORB
	LDA	DISPCE,X	;Get the chip select bits for this character
	STA	PIAORA		;Set the lines
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	CURCLP		;Clear the next cursor position

;Run a checksum on the ROM
	LDX	#$00
	LDA	#$00
	PGESUM	$F000
	PGESUM	$F100
	PGESUM	$F200
	PGESUM	$F300
	PGESUM	$F400
	PGESUM	$F500
	PGESUM	$F600
	PGESUM	$F700
	PGESUM	$F800
	PGESUM	$F900
	PGESUM	$FA00
	PGESUM	$FB00
	PGESUM	$FC00
	PGESUM	$FD00
	PGESUM	$FE00
	PGESUM	$FF00
	ORA	#$00		;Set the flags for A
	BEQ	ROMGUD
	SPMSG	RMFAIL
	BEQ	*

ROMGUD:	SPMSG	RMGOOD
	SDELAY

;Test the stack first so that we can use subroutine calls
	SPMSG	STTEST
	PGETST	$100		;Test stack page using the page test macro
	BCS	STBAD		;Output error message if the stack is bad


	LDX	#$00
STGLUP:	LDA	STGOOD,X
	JSR	COUT
	CPX	#20
	BNE	STGLUP
	JSR	DELAY

	
;Test zero-page too
	SPMSG	ZPTEST
	PGETST	$00
	BCS	ZPBAD

	LDA	#<ZPGOOD
	STA	MEMPLO
	LDA	#>ZPGOOD
	STA	MEMPHI
	JSR	PRINT
	JSR	DELAY

	JMP	PGSGUD		;Pages look good, jump to start



ZPBAD:	LDX	#$00
ZPBLP:	LDA	ZPFAIL,X	;Get the character to send to the display
	ORA	#$80		;Set the cursor select bit
	STA	PIAORB		;Set the data lines
	LDA	DISPCE,X	;Get the chip select bits for this character
	STA	PIAORA		;Set the lines
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	ZPBLP
	BEQ	*		;Just sit in a loop when done


STBAD:	SPMSG	STFAIL
	BEQ	*

	;Pages are good, now we can use zero-page and the stack
PGSGUD:	;Test the RIOT's RAM
	LDA	#<$A400
	STA	VAR2
	LDA	#>$A400
	STA	VAR3
	LDA	#<$A480
	STA	ENDPLO
	LDA	#>$A480
	STA	ENDPHI
	LDA	#$01
	STA	MAXPAS		;Only test the RIOT's RAM once
	JSR	MEMTST

	LDA	#<RIOTGD
	STA	MEMPLO
	LDA	#>RIOTGD
	STA	MEMPHI
	JSR	PRINT
	JSR	DELAY

FULTST:	JSR	MEMSIZ		;Size the memory and write the ending address to ENDPTR
	;Set up the starting memory address pointer
	LDA	#<MEMBEG
	STA	VAR2
	LDA	#>MEMBEG
	STA	VAR3
	;Go for the full 256 passes (this will take a while!)
	LDA	#$FF
	STA	MAXPAS
	JSR	MEMTST		;Start the full test

	JMP	FULTST		;Loop the main test


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MEMTST -- Memory Test
;
;Test memory from (VAR2, VAR3) to ENDPTR
;MAXPAS number of passes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MEMTST:
	JSR	DISCLR		;Clear the display
	LDX	#$00
	;Output the test starting address to characters 0-3
	LDA	VAR3		;MSB
	JSR	BYTOUT
	LDA	VAR2		;LSB
	JSR	BYTOUT
	;Separator
	LDA	#'-'
	JSR	COUT
	;Output the test ending address to character 4-7
	;Start by decrementing first to create a less confusing number
	LDA	ENDPLO
	BNE	LENPHI		;Leave end pointer high alone if no underflow
	DEC	ENDPHI
	;Print it
LENPHI:	DEC	ENDPLO
	LDA	ENDPHI
	JSR	BYTOUT
	LDA	ENDPLO
	JSR	BYTOUT
	;Now increment the end pointer back up to what the test exppects
	INC	ENDPLO
	BNE	IENPHI		;Don't increment the high byte if no overflow
	INC	ENDPHI		;Increment the high byte

IENPHI:	INX			;Space
	LDA	#'P'		;Pass count
	JSR	COUT
	LDA	#'='
	JSR	COUT

	;Reset and output the successful pass counter
	LDA	#$00
	STA	PASCTR
	JSR	BYTOUT

	INX			;Space
	LDA	#'C'		;Cycle count
	JSR	COUT
	LDA	#'='
	JSR	COUT

;0000-0000 P=00 C=00

	;Prepare the variables used by thes test
	LDX	#$00		;X is used to keep track of the sub-pass
	LDA	#$77		;Used for seeding something
	STA	VAR1

;Start of Test
STRTST:	JSR	RESTRT		;Move VAR2,VAR3 (user-entered starting address) into MEMPTR pointer

	TXA			;Output the current pass

	LDX	#17		;Start at character 17
	JSR	BYTOUT
	
	TAX			;Restore the pass number

;Set all memory locations from VAR2,VAR3 to ENDPTR to the value calculated by GTSVAL
TSTWRT:	JSR	GTSVAL		;Get a test data value based on the memory pointer address
	STA	(MEMPTR),Y	;Store it at the address we're testing
	JSR	INMPTR		;Increment the memory pointer
	BNE	TSTWRT		;Loop again if MEMPTR <> ENDPTR

	
;Read back all memory locations from VAR2,VAR3 to ENDPTR and compare them to the calculated GTSVAL
	JSR	RESTRT		;Restore START value to MEMPTR
TESTRD:	JSR	GTSVAL		;Get the test data value based on the current memory pointer
	CMP	(MEMPTR),Y		;Compare it to what was stored in the previous loop
	BNE	TSTERR		;If they're different, throw an error
	JSR	INMPTR		;Increment the memory pointer
	BNE	TESTRD		;Loop again if MEMPTR <> ENDPTR

	INX			;Increment the number of test passes
	BNE	STRTST		;If we're <256 passes, test again.


;Increment the pass counter and update the pass count on the display
	INC	PASCTR
	LDA	PASCTR
	CMP	MAXPAS		;Do we need to stop?
	BEQ	TSTDUN		;Stop the test and return
	LDX	#12
	JSR	BYTOUT
	LDX	#$00
	JMP	STRTST		;Start next pass!

TSTDUN:	RTS

;Diplay the test error code
;A contains the value that should have been read back
TSTERR:	STA	VAR3		;Save value for later
	LDA	(MEMPTR),Y
	STA	VAR2
	LDA	MEMPLO
	STA	ENDPLO
	LDA	MEMPHI
	STA	ENDPHI

;Output (MEMPHI,MEMPLO),VAR3,VAR2 in the form
; MEMPTR GOOD BAD
;ERROR@0000 E=00 R=00
	LDA	#<MEMERR
	STA	MEMPLO
	LDA	#>MEMERR
	STA	MEMPHI
	JSR	PRINT

	;Output error address
	LDX	#06

	LDA	ENDPHI
	JSR	BYTOUT
	LDA	ENDPLO
	JSR	BYTOUT
	
	LDX	#13
	LDA	VAR3
	JSR	BYTOUT

	LDX	#18
	LDA	VAR2
	JSR	BYTOUT

	JMP	*		;Just sit in a loop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MEMSIZ -- Autosize available RAM
;
;Searches system memory from MEMBEG on to find the end of
;writable RAM. Clobbers contents of memory tested.
;Calculates the amount of memory to test starting from
;
;pre: MEMBEG initialized to start of memory to be tested
;post: ENDPTR contains first non-RAM memory address
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MEMSIZ:	LDA	#<MEMBEG	;Load the starting address
	STA	ENDPLO
	LDA	#>MEMBEG
	STA	ENDPHI
	LDX	#00		;Use X as the zero source, and zero index

MEMSI1:	TXA			;Test by writing 0x00 first
	STA	(ENDPTR,X)	;Write it	
	LDA	(ENDPTR,X)	;Read it back
	BNE	MEMSEN		;Not 0x00, done

	CLC			;Now test with 0xFF
	SBC	#$00
	STA	(ENDPTR,X)	;Write it
	LDA	(ENDPTR,X)	;Read it back
	CMP	#$FF		;Compare it
	BNE	MEMSEN		;Not 0xFF, done

	INC	ENDPLO		;Increment low memory pointer
	BNE	MEMSI1		;No overflow, continue
	INC	ENDPHI		;Increment high memory pointer
	BNE	MEMSI1		;No overflow, continue

MEMSI2:	RTS			;We also end up here if we somehow have RAM
				;all the way to 0xFFFF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INMPTR -- Increment memory pointer
;
;Increments the memory pointer and compares the new value to
;ENDPTR. Compare flags are set.
;
;post: MEMPTR 16-bit value incremented
;post: Z flag set if MEMPTR == ENDPTR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
INMPTR:	INC	MEMPTR		;Increment the low byte
	BNE	INMPT1		;Didn't overflow, skip incrementing high byte
	INC	MEMPTR+1	;Increment the high byte

INMPT1:	LDA	MEMPTR+1	;Compare the high byte
	CMP	ENDPTR+1
	BNE	INMPT2		;Return with Z flag clear if different
	LDA	MEMPTR		;Compare the low byte
	CMP	ENDPTR

INMPT2:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTRT -- Restore start
;
;Move the VAR2,VAR3 pair into MEMPTR,MEMPTR+1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESTRT:	LDA	VAR2
	STA	MEMPTR
	LDA	VAR3
	STA	MEMPTR+1
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GTSVAL -- Get test value
;
;Calculates a byte that is derived from the current memory 
;address and pass count and return it in A.
;
;A = (MEMPTR ^ MEMPTR+1) ^ PASS_COUNT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GTSVAL:	LDA	MEMPTR
	EOR	MEMPTR+1
	STA	VAR1
	TXA
	EOR	VAR1
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;BYTOUT -- Display a byte on the AIM-65 display
;
;Outputs the ASCII hex representation of the byte in A on
;the AIM-65 display. High nybble is displayed at the
;position in X, low nybble at X+1.
;
;pre: A register contains byte to display
;pre: X register contains display position to start at
;post: ASCII hex representation of byte in A displayed
;post: A register contains original byte
;post: X = X+2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BYTOUT:	PHA			;Store byte to display
	PHA			;Again
	LSR	A		;Shift high nybble to low nybble
	LSR	A
	LSR	A
	LSR	A
	JSR	NYBOUT		;Display high nybble
	PLA			;Restore A
	JSR	NYBOUT		;Display low nybble
	PLA			;Restore A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NYBOUT -- Display a nybble on the AIM-65 display
;
;Outputs the hex nybble in the lower 4 bits of A as a
;single ASCII character.
;
;pre: A register contains nybble to print
;post: Low nybble of A displayed on AIM-65 display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NYBOUT:	AND	#$0F
	ORA	#$30		;0-9 ASCII bias

	CMP	#':'		;Greater than '9'?
	BMI	NYBGUD		;Nope, output the character
	CMP	#'G'		;Greater than 'G'?
	BCS	NYBBAD		;Yes, skip outputting the character

	CLC			;A-F ASCII bias
	ADC #$07

NYBGUD:	JMP COUT		;Echo the character, and save an RTS by using a jmp.
NYBBAD:	RTS			;Nybble is not valid

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;COUT -- Character Out
;
;Write the character in A to the AIM-65 display.
;
;pre: A register contains character to print
;pre: X register contains next empty character position
;post: character printed to AIM-65 display
;post X register contains next empty character position 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COUT:	JSR	SCHAR		;Display A at X
	INX			;Point to next empty character
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DISCLR -- Display Clear
;
;Clear the display by writing all spaces to it.
;
;post: AIM-65 display is cleared
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DISCLR:	LDA	#' '		;Display is ASCII, literal space
	LDX	#19		;Clear all 20 characters
DISCLP:	JSR	SCHAR		;Store space char at X position
	DEX
	CPX	#$FF		;Have we underflowed count?
	BNE	DISCLP		;No, send more spaces

	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRINT -- Print a string
;
;Prints a string pointed to by MEMPTR to the display.
;
;pre: MEMPTR points to a fixed length string
;post: string is printed to AIM-65 display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRINT:	PHA			;Preserve A
	TXA			;Preserve X
	PHA
	TYA			;Preserve Y
	PHA

	LDX	#$00
	LDY	#$00
PRINT1:	LDA	(MEMPTR),Y
	JSR	COUT
	INY
	CPX	#20		;Have we printed 20 chars yet?
	BNE	PRINT1		;No, print more

	PLA			;Restore Y
	TAY
	PLA			;Restore X
	TAX
	PLA			;Restore A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DELAY -- Delay for a bit
;
;Imprecise software delay routine.
;
;post: A register contains Y register
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DELAY:	TXA			;Save X on stack
	PHA
	TYA			;Save Y on stack
	PHA

	LDX	#$FF
DLOOP1:	LDY	#$FF

DLOOP2:	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DEY
	BNE	DLOOP2
	DEX
	BNE	DLOOP1

	PLA
	TAY			;Restore Y from stack
	PLA
	TAX			;Restore X from stack

	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SCHAR -- Set character
;
;Sets the display character at X to the character in A.
;
;pre: A register contains character to display
;pre: X register contains position to display character at
;post: character displayed on AIM-65 display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCHAR:	PHA			;Preserve A

	ORA	CHARMOD		;Disable cursor mode
	STA	PIAORB		;Character on data lines

	LDA	DISPCE,X	;Get the display chip select+character
				;select bit pattern
	STA	PIAORA		;Output the character address, select
				;the display, and keep ~W high

	AND	DISPWR		;Toggle *W low to write displays
	STA	PIAORA
	ORA	NDISPWR		;Toggle *W high to disable writing
	STA	PIAORA

	LDA	DCEIDLE		;Reset display select bits to idle
	STA	PIAORA
	LDA	CHARMOD		;Reset data bits to idle
	STA	PIAORB

	PLA			;Restore A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;String Constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RMFAIL:	.byte "ROM CHECKSUM FAILURE"
RMGOOD: .byte "ROM CHECKSUM PASSED "
ZPTEST:	.byte "TESTING ZERO-PAGE   "
ZPGOOD:	.byte "ZERO-PAGE PASSED    "
ZPFAIL:	.byte "ZERO-PAGE FAILURE   "
STTEST: .byte "TESTING STACK PAGE  "
STGOOD: .byte "STACK PAGE PASSED   "
STFAIL:	.byte "STACK PAGE FAILURE  "
RIOTFL: .byte "RIOT RAM FAILURE    "
RIOTGD: .byte "RIOT RAM PASSED     "
MEMERR: .byte "ERROR@0000 E=00 R=00"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DISPCE -- Table to decode display CE lines
;
;This table decodes chip select (CE) lines for the AIM-65's
;alphanumeric displays. These displays are addressed and
;controlled through PIA ports, rather than being directly on
;the 6502 system bus.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DISPCE:	.byte %11111011, %11111010, %11111001, %11111000
	.byte %11110111, %11110110, %11110101, %11110100
	.byte %11101111, %11101110, %11101101, %11101100
	.byte %11011111, %11011110, %11011101, %11011100
	.byte %10111111, %10111110, %10111101, %10111100

;Checksum byte. Set to something that makes the entire ROM sum out to $00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SYMBYT -- Checksum byte
;
;This checksum byte must be set such that the entire ROM
;checksums to 0x00. The ROM checksum test will fail
;otherwise, and further tests will not run.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SUMBYT:	.byte $100-$95

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;VECTORS -- Reset, NMI, and INT vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.segment "VECTORS"
.word	START
.word	START
.word	START