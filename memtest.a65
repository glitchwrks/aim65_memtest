;Memory Tester for the Rockwell AIM-65
;Using the memory test routines from the OSI MEMORY TEST from OS65D 2.0 published in OSI Small System Journal Vol1 No.3, Sept 1977
;Runs from the $F000 page 4K ROM
;
;Usage:
;Assemble the test. Burn the binary to a 2532 EPROM, or to a 2732 EPROM if using a revision 4/5 AIM-65 jumpered to support it.
;Insert the ROM into ROM socket Z22 ($F000) and power on the machine. The ROM will perform the following tests:
; - Stack page quick write presence
; - Zero page quick write presence
; - RIOT single-pass memory test
; - Full system memory test
;
;Stack Page Quick Write Presence:
;This test ensures that the stack page in low RAM is present and functional enough to run the rest of the tests. If this
;  test fails, ensure that the low RAM ICs are installed and are good. The test operates in the following way:
;$00 is written to and then read back from addresses $100 to $1FF. If anything except for $00 is read back, the test fails
;  and a message is displayed. $FF is then written to the same range and checked. If anything except for $FF is read back,
;  the test fails with the same error.
;
;Zero Page Quick Write Presence:
;This test ensures that the zero page in low RAM is present and functional enough to run the rest of the tests. If this
;  test fails, and the stack page test passes, the low RAM ICs are at fault. The operation of this test is identical
;  to the stack page quick test, except that it operates in the range of $00-$FF as opposed to $100-$1FF.
;
;RIOT Single-Pass Memory Test:
;This test checks the RAM of the RIOT separately. The RIOT's RAM is present at a higher memory address that is isolated from
;  the main system memory, necessitating the use of this separate test. The RIOT's function is not needed for the main system
;  memory test, but it is needed for the AIM-65 monitor ROM set. The test operates identically to the main system memory test
;  (which is described in the next test description), with the exception that only the address range of $A400-$A47F is tested,
;  and only one pass is performed.
;
;Full System Memory Test:
;This test tests the entire main system memory with the exception of zero page and the stack page. Before the test is run, a 
;  memory sizing routine is called which automatically determines the top of memory for the following test to test up to. 
;  The test itself then starts. The test display is shown as:
;
;  0300-XXXX P=YY C=ZZ
;
; - 0300: The starting address of the test. Set to $0300 for the full test, as this is where main memory starts. For the RIOT
;           single-pass test, this is set to $A400. Each memory test cycle starts at this address.
; - XXXX: The ending address of the test. Set based on the autosizing routine. For the RIOT single-pass test, this is set to
;           $A47F. Each memory test cycle ends at this address before starting over for the next cycle.
; - P=YY: The pass counter. Each pass takes 256 cycles. After 256 cycles, the pass counter increments by 1. For the RIOT
;           single-pass test, only one pass is performed.
; - C=ZZ: The cycle counter. The cycle counter is incremented every time the memory test works its way from the starting
;           address to the ending address. The cycle count itself is used as part of the memory test to "seed" the
;           pattern used during that cycle. Each cycle will therefore test every single bit pattern in every byte.
;
;If an error is encountered during the memory test, it will be displayed in the following format:
;
;  ERROR@XXXX E=YY R=ZZ
;
;  - XXXX: The address where the error was encountered.
;  - E=YY: The byte that was expected to be read from the address.
;  - R=ZZ: The byte that was actually read from the address.

MEMBEG	=	$200		;The starting address when probing for memory size

PIA	=	$AC00
PIAORA	=	PIA+0
PIADDA	=	PIA+0
PIACRA	=	PIA+1
PIAORB	=	PIA+2
PIADDB	=	PIA+2
PIACRB	=	PIA+3



USRCMD	=	$C4		;Command character entered by the user
PASCTR	=	$C5		;Pass Counter
MAXPAS	=	$C6		;Maximum number of passes
VAR1	=	$C7
VAR2	=	$C8
VAR3	=	$C9
MEMPTR	=	$CA
MEMPLO	=	MEMPTR
MEMPHI	=	MEMPTR+1
ENDPTR	=	$CC
ENDPLO	=	ENDPTR
ENDPHI	=	ENDPTR+1
TEMP	=	$CE


.segment "CODE"
START:	SEI
	LDX	#$FF
	TXS

	;Select the output registers of ports A and B
	LDA	#04
	STA	PIACRA
	STA	PIACRB

	;Reset the display select bits to their resting state
	LDA	#%11111100
	STA	PIAORA
	;Reset the data bits to their resting state
	LDA	#$80
	STA	PIAORB

	LDA	#00
	STA	PIACRA
	STA	PIACRB
	LDA	#$FF
	STA	PIADDA
	STA	PIADDB

	LDA	#04
	STA	PIACRA
	STA	PIACRB

	;Clear all of the cursor bits
	LDX	#$00		
CURCLP:	LDA	#$00		;D0 = 0, ~CU = 0
	STA	PIAORB
	LDA	DISPCE,X	;Get the chip select bits for this character
	STA	PIAORA		;Set the lines
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	CURCLP		;Clear the next cursor position
;Display test! Please remove later!
;	LDX	#$00
;TSTLUP:	LDA	TESTSTRING,X
;	JSR	COUT
;	CPX	#20
;	BNE	TSTLUP
;
;	JMP	*

;Test the stack first so that we can use subroutine calls
	LDX	#$00
STTLUP:	LDA	#$00
	STA	$100,X
	LDA	$100,X
	BNE	STBAD
	LDA	#$FF
	STA	$100,X
	LDA	$100,X
	CMP	#$FF
	BNE	STBAD
	INX
	BNE	STTLUP


	LDX	#$00
STGLUP:	LDA	STGOOD,X
	JSR	COUT
	CPX	#20
	BNE	STGLUP
	JSR	DELAY

	
;Test zero-page too

ZPTLUP:	LDA	#$00
	STA	$00,X
	LDA	$00,X
	BNE	ZPBAD
	LDA	#$FF
	STA	$00,X
	LDA	$00,X
	CMP	#$FF
	BNE	ZPBAD
	INX
	BNE	ZPTLUP

	LDA	#<ZPGOOD
	STA	MEMPLO
	LDA	#>ZPGOOD
	STA	MEMPHI
	JSR	PRINT
	JSR	DELAY

	JMP	PGSGUD		;Pages look good, jump to start



ZPBAD:	LDX	#$00
ZPBLP:	LDA	ZPFAIL,X	;Get the character to send to the display
	ORA	#$80		;Set the cursor select bit
	STA	PIAORB		;Set the data lines
	LDA	DISPCE,X	;Get the chip select bits for this character
	STA	PIAORA		;Set the lines
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	ZPBLP
	BEQ	*		;Just sit in a loop when done


STBAD:	LDX	#$00
STBLP:	LDA	STFAIL,X	;Get the character to send to the display
	ORA	#$80		;Set the cursor select bit
	STA	PIAORB		;Set the data lines
	LDA	DISPCE,X	;Get the chip select bits for this character
	STA	PIAORA		;Set the lines
	AND	#$7F		;Set ~W low
	STA	PIAORA
	ORA	#$80		;Set ~W high
	STA	PIAORA

	INX
	CPX	#20
	BNE	STBLP
	BEQ	*		;Just sit in a loop when done

	;Pages are good, now we can use zero-page and the stack
PGSGUD:	;Test the RIOT's RAM
	LDA	#<$A400
	STA	VAR2
	LDA	#>$A400
	STA	VAR3
	LDA	#<$A480
	STA	ENDPLO
	LDA	#>$A480
	STA	ENDPHI
	LDA	#$01
	STA	MAXPAS		;Only test the RIOT's RAM once
	JSR	MEMTST

	LDA	#<RIOTGD
	STA	MEMPLO
	LDA	#>RIOTGD
	STA	MEMPHI
	JSR	PRINT
	JSR	DELAY

FULTST:	JSR	MEMSIZ		;Size the memory and write the ending address to ENDPTR
	;Set up the starting memory address pointer
	LDA	#<MEMBEG
	STA	VAR2
	LDA	#>MEMBEG
	STA	VAR3
	;Go for the full 256 passes (this will take a while!)
	LDA	#$FF
	STA	MAXPAS
	JSR	MEMTST		;Start the full test

	JMP	FULTST		;Loop the main test


	

;Start the test!
;X is used to keep track of the number of passes
;Y should be 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MEMTST -- Memory Test
;
;Test memory from (VAR2, VAR3) to ENDPTR
;MAXPAS number of passes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MEMTST:
	JSR	DISCLR		;Clear the display
	LDX	#$00
	;Output the test starting address to characters 0-3
	LDA	VAR3		;MSB
	JSR	BYTOUT
	LDA	VAR2		;LSB
	JSR	BYTOUT
	;Separator
	LDA	#'-'
	JSR	COUT
	;Output the test ending address to character 4-7
	;Start by decrementing first to create a less confusing number
	LDA	ENDPLO
	BNE	LENPHI		;Leave end pointer high alone if no underflow
	DEC	ENDPHI
	;Print it
LENPHI:	DEC	ENDPLO
	LDA	ENDPHI
	JSR	BYTOUT
	LDA	ENDPLO
	JSR	BYTOUT
	;Now increment the end pointer back up to what the test exppects
	INC	ENDPLO
	BNE	IENPHI		;Don't increment the high byte if no overflow
	INC	ENDPHI		;Increment the high byte

IENPHI:	INX			;Space
	LDA	#'P'		;Pass count
	JSR	COUT
	LDA	#'='
	JSR	COUT

	;Reset and output the successful pass counter
	LDA	#$00
	STA	PASCTR
	JSR	BYTOUT

	INX			;Space
	LDA	#'C'		;Cycle count
	JSR	COUT
	LDA	#'='
	JSR	COUT

;0000-0000 P=00 C=00

	;Prepare the variables used by thes test
	LDX	#$00		;X is used to keep track of the sub-pass
	LDA	#$77		;Used for seeding something
	STA	VAR1

;Start of Test
STRTST:	JSR	RESTRT		;Move VAR2,VAR3 (user-entered starting address) into MEMPTR pointer

	TXA			;Output the current pass

	LDX	#17		;Start at character 17
	JSR	BYTOUT
	
	TAX			;Restore the pass number

;Set all memory locations from VAR2,VAR3 to ENDPTR to the value calculated by GTSVAL
TSTWRT:	JSR	GTSVAL		;Get a test data value based on the memory pointer address
	STA	(MEMPTR),Y	;Store it at the address we're testing
	JSR	INMPTR		;Increment the memory pointer
	BNE	TSTWRT		;Loop again if MEMPTR <> ENDPTR

	
;Read back all memory locations from VAR2,VAR3 to ENDPTR and compare them to the calculated GTSVAL
	JSR	RESTRT		;Restore START value to MEMPTR
TESTRD:	JSR	GTSVAL		;Get the test data value based on the current memory pointer
	CMP	(MEMPTR),Y		;Compare it to what was stored in the previous loop
	BNE	TSTERR		;If they're different, throw an error
	JSR	INMPTR		;Increment the memory pointer
	BNE	TESTRD		;Loop again if MEMPTR <> ENDPTR

	INX			;Increment the number of test passes
	BNE	STRTST		;If we're <256 passes, test again.


;Increment the pass counter and update the pass count on the display
	INC	PASCTR
	LDA	PASCTR
	CMP	MAXPAS		;Do we need to stop?
	BEQ	TSTDUN		;Stop the test and return
	LDX	#12
	JSR	BYTOUT
	LDX	#$00
	JMP	STRTST		;Start next pass!

TSTDUN:	RTS

;Diplay the test error code
;A contains the value that should have been read back
TSTERR:	STA	VAR3		;Save value for later
	LDA	(MEMPTR),Y
	STA	VAR2
	LDA	MEMPLO
	STA	ENDPLO
	LDA	MEMPHI
	STA	ENDPHI

;Output (MEMPHI,MEMPLO),VAR3,VAR2 in the form
; MEMPTR GOOD BAD
;ERROR@0000 E=00 R=00
	LDA	#<MEMERR
	STA	MEMPLO
	LDA	#>MEMERR
	STA	MEMPHI
	JSR	PRINT

	;Output error address
	LDX	#06

	LDA	ENDPHI
	JSR	BYTOUT
	LDA	ENDPLO
	JSR	BYTOUT
	
	LDX	#13
	LDA	VAR3
	JSR	BYTOUT

	LDX	#18
	LDA	VAR2
	JSR	BYTOUT

	JMP	*		;Just sit in a loop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;MEMSIZ -- Memory Size
;Calculates the amount of memory to test starting from
;  $0200 and stopping once it can't write.
;At the end, ENDPTR contains the first non-writable
;  memory address.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MEMSIZ:	LDA	#<MEMBEG	;Load the starting address
	STA	ENDPLO
	LDA	#>MEMBEG
	STA	ENDPHI
	LDX	#00		;Use X as the zero source, and zero index

MEMSLP:	TXA			;0 -> A
	;Test by writing $00
	STA	(ENDPTR,X)	;Write it	
	LDA	(ENDPTR,X)	;Read it back
	BNE	MEMSEN		;Didn't read back $00. End sizing.
	;Test by writing $FF
	CLC			;Complement A ($00 -> $FF)
	SBC	#$00
	STA	(ENDPTR,X)	;Write it
	LDA	(ENDPTR,X)	;Read it back
	CMP	#$FF		;Compare it
	BNE	MEMSEN		;Didn;t read back $FF. End sizing.
	;Increment to the next byte
	INC	ENDPLO
	BNE	MEMSLP
	INC	ENDPHI
	BNE	MEMSLP

MEMSEN:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INMPTR -- Increment Memory Pointer
;Increments the memory pointer and compares the new value
;  to ENDPTR. Compare flags are set.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
INMPTR:	INC	MEMPTR		;Increment the low byte
	BNE	IMPCMP		;Didn't overflow, skip incrementing high byte
	INC	MEMPTR+1	;Increment the high byte
;Increment Memory Pointer CoMPare
IMPCMP:	LDA	MEMPTR+1	;Compare the high byte
	CMP	ENDPTR+1
	BNE	IMPEND		;Return with Z flag clear if different
	LDA	MEMPTR		;Compare the low byte
	CMP	ENDPTR

IMPEND:	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESTRT -- Restore Start
;Move the VAR2,VAR3 pair into MEMPTR,MEMPTR+1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESTRT:	LDA	VAR2
	STA	MEMPTR
	LDA	VAR3
	STA	MEMPTR+1
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GTSVAL -- Get Test Value
;Calculates a byte that is derived from the current
;  memory address and pass count and return it in A
;A = (MEMPTR ^ MEMPTR+1) ^ PASS_COUNT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GTSVAL:	LDA	MEMPTR
	EOR	MEMPTR+1
	STA	VAR1
	TXA
	EOR	VAR1
	RTS

BYTOUT:	PHA
	PHA
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	JSR	NYBOUT
	PLA
	JSR	NYBOUT
	PLA
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;NYBOUT -- Nybble Out
;Outputs the hex nybble in the lower 4 bits of A as a
;  single ASCII character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NYBOUT:	AND	#$0F
	ORA	#$30		;Place the value up in the ASCII range

	CMP	#':'		;Greater than '9'?
	BMI	NYBGUD		;Nope, output the character
	CMP	#'G'		;Greater than 'G'?
	BCS	NYBBAD		;Yes, skip outputting the character

	CLC			;Add 7 to push the value to A-F if it is greater than 9
	ADC #$07

NYBGUD:	JMP COUT		;Echo the character, and save an RTS by using a jmp.
NYBBAD:	RTS			;Nybble is not valid

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;COUT -- Character Out
;
;Write the character in A to the display character indexed
;  by X and then increments X
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COUT:	JSR	SCHAR		;Set character
	INX			;Advance to the next character of the display
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DISCLR -- Display Clear
;
;Clear the display by writing all spaces to it
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DISCLR:	LDA	#' '		;Space character
	LDX	#19		;All 20 characters
DISCLP:	JSR	SCHAR
	DEX
	CPX	#$FF
	BNE	DISCLP

	RTS


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;PRINT -- Print a string
;
;Prints a string pointed to by MEMPTR to the display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRINT:	PHA			;Preserve A
	TXA			;Preserve X
	PHA
	TYA			;Preserve Y
	PHA

	LDX	#$00
	LDY	#$00
PRLOOP:	LDA	(MEMPTR),Y
	JSR	COUT
	INY
	CPX	#20
	BNE	PRLOOP

	PLA			;Restore Y
	TAY
	PLA			;Restore X
	TAX
	PLA			;Restore A
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;DELAY -- Delay for a bit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DELAY:	TXA
	PHA
	TYA
	PHA

	LDX	#$FF
DLOOP1:	LDY	#$FF

DLOOP2:	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DEY
	BNE	DLOOP2
	DEX
	BNE	DLOOP1

	PLA
	TAY
	PLA
	TAX

	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;SCHAR -- Set Character
;
;Sets the display character X to the character in A
;
;Display PIA mapping:
;PA0 = A0	Digit select 0
;PA1 = A1	Digit select 1
;PA2 = ~CE1	Display 0	111110XX 0111 1100
;PA3 = ~CE2	Display 1	111101XX
;PA4 = ~CE3	Dispaly 2	111011XX
;PA5 = ~CE4	Display 3	110111XX
;PA6 = ~CE5	Display 4	101111XX
;PA7 = ~W	Write		Data is clocked into display on rising edge
;
;PB0-PB6 = D0-D6	Data
;PB7 = ~CU	Cursor input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SCHAR:	PHA			;Preserve A

	ORA	#$80		;Set the Cursor Input bit
	STA	PIAORB		;Set the data lines

	LDA	DISPCE,X	;Get the display chip select+character select bit pattern
	STA	PIAORA		;Output the character address, select the display, and keep ~W high
	;Toggle ~W low
	AND	#$7F
	STA	PIAORA
	;Toggle ~W high
	ORA	#$80
	STA	PIAORA

	;Reset the display select bits to their resting state
	LDA	#%11111100
	STA	PIAORA
	;Reset the data bits to their resting state
	LDA	#$80
	STA	PIAORB

	PLA			;Restore A
	RTS

ZPFAIL:	.byte "ZERO-PAGE FAILURE   "
ZPGOOD:	.byte "ZERO-PAGE PASSED    "
STGOOD: .byte "STACK PAGE PASSED   "
STFAIL:	.byte "STACK PAGE FAILURE  "
RIOTFL: .byte "RIOT RAM FAILURE    "
RIOTGD: .byte "RIOT RAM PASSED     "
MEMERR: .byte "ERROR@0000 E=00 R=00"

;Display CE decode table
DISPCE:	.byte %11111011, %11111010, %11111001, %11111000
	.byte %11110111, %11110110, %11110101, %11110100
	.byte %11101111, %11101110, %11101101, %11101100
	.byte %11011111, %11011110, %11011101, %11011100
	.byte %10111111, %10111110, %10111101, %10111100
;Display Character decode table
DISPCH: .byte 3,2,1,0
TESTSTRING:	.byte "ABCDEFGHIJKLMNOPQRST",0

.segment "VECTORS"
.word	START
.word	START
.word	START